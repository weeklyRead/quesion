第一期
---

试题 @hb  /  回答 @whj

1. 因为js是单线程运行的，setTimeout的第二个参数设置了在队列的某个时间点运行该任务，但如果这个时间点到的时候队列上有其他任务在运行，就需要先等待那个任务运行完才能运行setTimeout的任务，于是就产生了延迟。

    该误差只能尽量减少，无法根治避免，具体方法如下：
    ```js
    (function(){

        let startTime = Date.parse(new Date());
        let count = 0;
        const space = 1000;
        let nextSpace = space;

        function loop(){

            setTimeout(function(){

                if(count < 5){
                    count ++;
                    let lessTime = space*count - (Date.parse(new Date()) - startTime);
                    nextSpace = space - lessTime;

                    console.log(`count : ${count}, lessTime : ${lessTime}, nextSpace : ${nextSpace}`)
                    loop();
                }
            }, nextSpace);
        };

        loop();
       
    }())

    ```


2. var的性能最高,let 和 const的次之，因为let和const需要做块级作用域的转换


3. === 的性能更好， 因为===是严格模式的对比； == 需要先专换成相通的类型，再做对比


4. 
    ```javascript
    let Origin= function () {};
    Origin.prototype.find = 1;  
    Origin.prototype.hide = 2;
    
    let o = new Origin();
    o.find = 3;
    o.hide = 3;
    
    console.log(Origin.find, Origin.hide);  // undefind,undefined
    console.log(o.find, o.hide);    // 3,3
    ```

5. 
    | 类别 | commonjs (require) | es6 (import) |
    |:-|:-|:-|
    | 加载 | 运行时加载 | 编译时加载 |
    | 引入 | 随便哪都可以引入 | 只能在顶部引入 |
    | 内容或者路径错误 | 运行时才会报错 | 编译时就会报错 |
    | 引用 | 基本类型深拷贝，复杂类型浅拷贝 | 浅拷贝 | 
    | this指向 | 指向当前模块 | 指向undefined |
    | 缓存 | 运行一次后缓存在系统中，之后都返回第一次的结果 | 不缓存结果 | 


6. 

7.

8.

9.

10.
